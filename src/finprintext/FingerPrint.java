package finprintext;

import java.util.ArrayList;

/**
 * Created by Acer on 2016-11-06.
 * 提取指纹类
 * 提取指纹步骤：
 * 1.调用Read类的read()函数获取double[][] data数组，并将其传到double[] timeDomain中（double[] timeDomain = data[0];）
 * 2.调用getFreqDomain(timeDomain)获取包含每帧最强频率的数组
 * 3.调用combineHash()，函数的返回值即为包含所有组合哈希的指纹数组
 */
public class FingerPrint {
    public static final int N = 3;

    private ArrayList<int[]> constel_data = new ArrayList<>();
    private int id;

    /**
     * For songs about to add into DB
     * @param id
     */
    public FingerPrint(int id) {
        this.id = id;
    }

    /**
     * For songs about to be searched
     */
    public FingerPrint() {
        this.id = -1;
    }

    /**
     * 将时域数据用FFT转化为频域数据，并获取振幅最大的N个值对应的下标
     * @param timeDomain 文件读取部分获得的时域数据
     */
    public void getFreqDomain(double[] timeDomain) {
        int frames = (int)Math.ceil(timeDomain.length / 4096.0);//帧数

        int num = frames * FFT.WINDOW_SIZE;
        double[] freqDomain = new double[num];//频域数据

        double[] data = new double[num];
        double[] slice = new double[FFT.WINDOW_SIZE];

        for(int i = 0; i < num; i++) {
            if(i >= timeDomain.length)
                data[i] = 0;
            else
                data[i] = timeDomain[i];
        }

        //对每帧进行fft，并获取每帧的N个最强频率
        for(int i = 0; i < frames; i++) {
            for(int j = 0; j < FFT.WINDOW_SIZE; j++)
                slice[j] = data[i * FFT.WINDOW_SIZE + j];
            slice  = FFT.fft(slice);
            append(slice);
        }
    }

    /**
     * Append a column of frequency peaks to the constellation map.
     * A frequency peak is a frequency value whose amplitude is the highest among
     * all frequencies in a frequency interval.
     * （获取N个最强频率）
     *
     * @param freqDomain The frequency domain generated by FFT.
     */
    private void append(double[] freqDomain) {
        int[] freqPeaks = new int[N];

        /**
         * TODO: Either find N frequencies with the highest amplitude(energy),
         * or find the frequency with the max energy within each interval.
         */
        double max1 = 0.0;
        double max2 = 0.0;
        double max3 = 0.0;

        //找出每帧的N个最强频率
        for(int i = 0; i < FFT.WINDOW_SIZE  / 8.0; i++) {
            if(freqDomain[i] > max1) {
                max1 = freqDomain[i];
                freqPeaks[0] = i;
            }
        }
        freqDomain[freqPeaks[0]] = 0;
        for(int i = 0; i < FFT.WINDOW_SIZE / 8.0; i++) {
            if(freqDomain[i] > max2) {
                max2 = freqDomain[i];
                freqPeaks[1] = i;
            }
        }
        freqDomain[freqPeaks[1]] = 0;
        for(int i = 0; i < FFT.WINDOW_SIZE / 8.0; i++) {
            if(freqDomain[i] > max3) {
                max3 = freqDomain[i];
                freqPeaks[2] = i;
            }
        }

        constel_data.add(freqPeaks);
    }

    /**
     * Generate fingerprints using Combinational Hash.
     * For each frequency peak, generate 6 fingerprints with its 6 successors.
     * （组合哈希）
     *
     * @return
     */
    public ArrayList<ShazamHash> combineHash() {
        double coef = (44100.0 - 1.0) / (FFT.WINDOW_SIZE - 1); //线性转换系数

        if (constel_data.size() < 3)
            throw new RuntimeException("Too few frequency peaks");

        ArrayList<ShazamHash> hashes = new ArrayList<ShazamHash>();
        for (int i = 0; i < constel_data.size() - 2; ++i) {
            for (int k = 0; k < N; ++k) {
                // "Combine" with all peak frequencies inside its next two frames.
                for (int j = 1; j <= 2; ++j) {
                    for (int kk = 0; kk < N; ++kk) {
                        ShazamHash hash = new ShazamHash();
                        hash.f1 = (short) (constel_data.get(i)[k] * coef + 1);
                        hash.f2 = (short) (constel_data.get(i + j)[kk] * coef +1);
                        hash.dt = (short) j;
                        hash.offset = i + 1;
                        hash.song_id = id;
                        hashes.add(hash);
                    }
                }
            }
        }
        return hashes;
    }
}